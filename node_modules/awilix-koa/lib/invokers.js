"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.inject = exports.makeResolverInvoker = exports.makeClassInvoker = exports.makeFunctionInvoker = exports.makeInvoker = void 0;
var awilix_1 = require("awilix");
var utils_1 = require("awilix/lib/utils");
var assert_1 = __importDefault(require("assert"));
/**
 * Creates either a function invoker or a class invoker, based on whether
 * the argument can be classified as a class or not. Uses Awilix' `isClass` utility.
 *
 * @param functionOrClass
 * The function or class to invoke.
 *
 * @param opts
 * Resolver options for the class/function.
 */
function makeInvoker(functionOrClass, opts) {
    return (0, utils_1.isClass)(functionOrClass)
        ? makeClassInvoker(functionOrClass, opts)
        : makeFunctionInvoker(functionOrClass, opts);
}
exports.makeInvoker = makeInvoker;
/**
 * Returns a function that when called with a name,
 * returns another function to be used as Koa middleware.
 * That function will run `fn` with the container cradle as the
 * only parameter, and then call the `methodToInvoke` on
 * the result.
 *
 * @param {Function} fn
 * @param opts
 * @return {(methodToInvoke: string) => (ctx) => void}
 */
function makeFunctionInvoker(fn, opts) {
    return makeResolverInvoker((0, awilix_1.asFunction)(fn, opts));
}
exports.makeFunctionInvoker = makeFunctionInvoker;
/**
 * Same as `makeInvoker` but for classes.
 *
 * @param {Class} Class
 * @param opts
 * @return {(methodToInvoke: string) => (ctx) => void}
 */
function makeClassInvoker(Class, opts) {
    return makeResolverInvoker((0, awilix_1.asClass)(Class, opts));
}
exports.makeClassInvoker = makeClassInvoker;
/**
 * Returns a function that when called with a method name,
 * returns another function to be used as Koa middleware.
 * That function will run `container.build(resolver)`, and
 * then call the method on the result, passing in the Koa context
 * and `next()`.
 *
 * @param {Resolver} resolver
 * @return {(methodToInvoke: string) => (ctx) => void}
 */
function makeResolverInvoker(resolver) {
    var singleton = resolver.lifetime === 'SINGLETON';
    var _resolved;
    /**
     * 2nd step is to create a method to invoke on the result
     * of the resolver.
     *
     * @param  {MethodName} methodToInvoke
     * @return {(ctx) => void}
     */
    return function makeMemberInvoker(methodToInvoke) {
        /**
         * The invoker middleware.
         *
         * @param  {Koa.Context} ctx
         * @param  {...*} rest
         * @return {*}
         */
        return function memberInvoker(ctx) {
            var rest = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                rest[_i - 1] = arguments[_i];
            }
            var container = ctx.state.container;
            if (!container) {
                throw new Error('Awilix container not found on Koa state object. Please ensure you use either scopePerRequest or attachContainer');
            }
            var resolved;
            if (singleton) {
                if (!_resolved) {
                    _resolved = container.build(resolver);
                }
                resolved = _resolved;
            }
            else {
                resolved = container.build(resolver);
            }
            (0, assert_1.default)(methodToInvoke, "methodToInvoke must be a valid method type, such as string, number or symbol, but was ".concat(String(methodToInvoke)));
            return resolved[methodToInvoke].apply(resolved, __spreadArray([ctx], rest, false));
        };
    };
}
exports.makeResolverInvoker = makeResolverInvoker;
/**
 * Injects dependencies into the middleware factory when the middleware is invoked.
 *
 * @param factory
 */
function inject(factory) {
    var resolver = getResolver(factory);
    /**
     * The invoker middleware.
     */
    return function middlewareFactoryHandler(ctx) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        var container = ctx.state.container;
        var resolved = container.build(resolver);
        return resolved.apply(void 0, __spreadArray([ctx], rest, false));
    };
}
exports.inject = inject;
/**
 * Wraps or returns a resolver.
 */
function getResolver(arg) {
    if (typeof arg === 'function') {
        return (0, awilix_1.asFunction)(arg);
    }
    return arg;
}
//# sourceMappingURL=invokers.js.map