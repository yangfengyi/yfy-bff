"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.listModules = listModules;
const fast_glob_1 = __importDefault(require("fast-glob"));
const path = __importStar(require("path"));
const utils_1 = require("./utils");
// Regex to extract the module name.
const nameExpr = /(.*)\..*/i;
/**
 * Internal method for globbing a single pattern.
 *
 * @param  {String} globPattern
 * The glob pattern.
 *
 * @param  {String} opts.cwd
 * Current working directory, used for resolving filepaths.
 * Defaults to `process.cwd()`.
 *
 * @return {[{name, path, opts}]}
 * The module names and paths.
 *
 * @api private
 */
function _listModules(globPattern, opts) {
    opts = { cwd: process.cwd(), glob: fast_glob_1.default.sync, ...opts };
    let patternOpts = null;
    if (Array.isArray(globPattern)) {
        patternOpts = globPattern[1];
        globPattern = globPattern[0];
    }
    // Replace Windows path separators with Posix path
    globPattern = globPattern.replace(/\\/g, '/');
    const result = opts.glob(globPattern, { cwd: opts.cwd });
    const mapped = result.map((p) => ({
        name: nameExpr.exec(path.basename(p))[1],
        path: path.resolve(opts.cwd, p),
        opts: patternOpts,
    }));
    return mapped;
}
/**
 * Returns a list of {name, path} pairs,
 * where the name is the module name, and path is the actual
 * full path to the module.
 *
 * @param  {String|Array<String>} globPatterns
 * The glob pattern as a string or an array of strings.
 *
 * @param  {String} opts.cwd
 * Current working directory, used for resolving filepaths.
 * Defaults to `process.cwd()`.
 *
 * @return {[{name, path}]}
 * An array of objects with the module names and paths.
 */
function listModules(globPatterns, opts) {
    if (Array.isArray(globPatterns)) {
        return (0, utils_1.flatten)(globPatterns.map((p) => _listModules(p, opts)));
    }
    return _listModules(globPatterns, opts);
}
//# sourceMappingURL=list-modules.js.map